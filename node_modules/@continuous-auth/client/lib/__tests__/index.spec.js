"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../index");
const circleci_1 = require("../circleci");
const travisci_1 = require("../travisci");
jest.mock('../circleci');
jest.mock('../travisci');
const mockedRequestThroughCircleCI = circleci_1.requestThroughCircleCI;
const mockedRequestThroughTravisCI = travisci_1.requestThroughTravisCI;
describe('@continuous-auth/client', () => {
    let env;
    beforeEach(() => {
        env = { ...process.env };
    });
    afterEach(() => {
        process.env = env;
    });
    it('should throw an error when CFA_SECRET is not set', async () => {
        await expect((0, index_1.getOtp)()).rejects.toMatchSnapshot();
    });
    it('should throw an error when CFA_PROJECT_ID is not set', async () => {
        process.env.CFA_SECRET = 'test';
        await expect((0, index_1.getOtp)()).rejects.toMatchSnapshot();
    });
    it('should throw an error on an unsupported CI platform', async () => {
        process.env.CFA_SECRET = 'test';
        process.env.CFA_PROJECT_ID = '123';
        await expect((0, index_1.getOtp)()).rejects.toMatchSnapshot();
    });
    it('should use the circleci provider on circleci', async () => {
        process.env.CFA_SECRET = 'secret';
        process.env.CFA_PROJECT_ID = '123';
        process.env.CIRCLECI = 'true';
        mockedRequestThroughCircleCI.mockReturnValue(Promise.resolve({ response: 'example token' }));
        const token = await (0, index_1.getOtp)();
        expect(token).toEqual('example token');
    });
    it('should use the travisci provider on travisci', async () => {
        process.env.CFA_SECRET = 'secret';
        process.env.CFA_PROJECT_ID = '123';
        process.env.TRAVIS = 'true';
        mockedRequestThroughTravisCI.mockReturnValue(Promise.resolve({ response: 'travis token' }));
        const token = await (0, index_1.getOtp)();
        expect(token).toEqual('travis token');
    });
});
//# sourceMappingURL=index.spec.js.map