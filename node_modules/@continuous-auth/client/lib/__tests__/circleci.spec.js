"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const circleci_1 = require("../circleci");
describe('getProofThroughCircleCI', () => {
    let mockClient;
    const client = () => mockClient;
    let consoleSpy;
    beforeEach(() => {
        mockClient = {
            post: jest.fn(),
        };
        consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => null);
        (0, circleci_1._setRetryIntervalForTesting)(10);
    });
    afterEach(() => {
        (0, circleci_1._setRetryIntervalForTesting)(10000);
    });
    it('should error out if the start request fails', async () => {
        mockClient.post.mockReturnValue(Promise.resolve({
            status: 401,
        }));
        await expect((0, circleci_1.requestThroughCircleCI)(client(), '1')).rejects.toMatchSnapshot();
    });
    it('should log out the provided proof content', async () => {
        mockClient.post.mockReturnValue(Promise.resolve({
            status: 200,
            data: {
                proof: 'abcdefg',
            },
        }));
        await (0, circleci_1.requestThroughCircleCI)(client(), '1');
        expect(consoleSpy).toHaveBeenCalledTimes(2);
        expect(consoleSpy).toHaveBeenNthCalledWith(1, '\n\n\nProof:');
        expect(consoleSpy).toHaveBeenNthCalledWith(2, 'abcdefg');
    });
    it('should error out if the validation request fails', async () => {
        mockClient.post.mockReturnValueOnce(Promise.resolve({
            status: 200,
            data: {
                proof: 'my_proof',
            },
        }));
        mockClient.post.mockReturnValueOnce(Promise.resolve({
            status: 403,
        }));
        await expect((0, circleci_1.requestThroughCircleCI)(client(), '1')).rejects.toMatchSnapshot();
    });
    it('should error out if the acquire request fails', async () => {
        mockClient.post.mockReturnValueOnce(Promise.resolve({
            status: 200,
            data: {
                proof: 'my_proof',
            },
        }));
        mockClient.post.mockReturnValueOnce(Promise.resolve({
            status: 200,
        }));
        mockClient.post.mockReturnValueOnce(Promise.resolve({
            status: 400,
        }));
        await expect((0, circleci_1.requestThroughCircleCI)(client(), '1')).rejects.toMatchSnapshot();
    });
    it('should eventually error out if one of the acquire requests fails', async () => {
        mockClient.post.mockReturnValueOnce(Promise.resolve({
            status: 200,
            data: {
                proof: 'my_proof',
            },
        }));
        mockClient.post.mockReturnValueOnce(Promise.resolve({
            status: 200,
        }));
        mockClient.post.mockReturnValueOnce(Promise.resolve({
            status: 204,
        }));
        mockClient.post.mockReturnValueOnce(Promise.resolve({
            status: 400,
        }));
        await expect((0, circleci_1.requestThroughCircleCI)(client(), '1')).rejects.toMatchSnapshot();
    });
    it('should keep trying to acquire until content is available', async () => {
        mockClient.post.mockReturnValueOnce(Promise.resolve({
            status: 200,
            data: {
                proof: 'my_proof',
            },
        }));
        mockClient.post.mockReturnValueOnce(Promise.resolve({
            status: 200,
        }));
        mockClient.post.mockReturnValueOnce(Promise.resolve({
            status: 204,
        }));
        mockClient.post.mockReturnValueOnce(Promise.resolve({
            status: 200,
            data: {
                token: '12345',
            },
        }));
        await expect((0, circleci_1.requestThroughCircleCI)(client(), '1')).resolves.toEqual({ token: '12345' });
    });
});
//# sourceMappingURL=circleci.spec.js.map